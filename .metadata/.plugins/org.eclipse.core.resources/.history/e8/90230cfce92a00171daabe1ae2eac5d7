#include <stdio.h>
#include <unistd.h>       /* for sleep() */
#include <stdint.h>       /* for uintptr_t */
#include <hw/inout.h>     /* for in*() and out*() functions */
#include <sys/neutrino.h> /* for ThreadCtl() */
#include <sys/mman.h>     /* for mmap_device_io() */
#include <cstdlib>
#include <iostream>
#include <pthread.h>
#include <ctime>
#include <queue>
#include <string>
#include <sys/mman.h>
#include <sys/time.h>
#include <math.h>

#define BASE 0x280
#define CONTROL_REGISTER BASE+11
#define INIT_BIT 0x00
#define PORT_LENGTH 1

uintptr_t ctrl_handle;

bool checkstatus() // returns 0 if ok, -1 if error
	{
	int i;
	for (i = 0; i < 20000; i++){
		ctrl_handle = mmap_device_io( PORT_LENGTH, BASE+3 );
	if (!(in8(ctrl_handle) & 0x80)) return(false);} // conversion completed
	return(true); // conversion did not complete
	}

/* ______________________________________________________________________ */
int main( )
{
	int privity_err;

		uintptr_t data_handle;

		/* Give this thread root permissions to access the hardware */
		privity_err = ThreadCtl( _NTO_TCTL_IO, NULL );
		if ( privity_err == -1 )
		{
			fprintf( stderr, "can't get root permissions\n" );
			return EXIT_SUCCESS;
		}

		/* Get a handle to the parallel port's Control register */
		ctrl_handle = mmap_device_io( PORT_LENGTH, CONTROL_REGISTER );

		/* Initialise the parallel port */
		out8( ctrl_handle, INIT_BIT );

	ctrl_handle = mmap_device_io( PORT_LENGTH, BASE+2 );
	out8(ctrl_handle, 0x22);// example, set channel range to fixed channel 2
	ctrl_handle = mmap_device_io( PORT_LENGTH, BASE+3 );
	out8(ctrl_handle, 0x01); // example: set gain = 2
	ctrl_handle = mmap_device_io( PORT_LENGTH, BASE+1 );
	out8(ctrl_handle, 2); // set page
	ctrl_handle = mmap_device_io( PORT_LENGTH, BASE+13 );
	out8(ctrl_handle, 0x00); // example: sets bipolar, single-ended

	ctrl_handle = mmap_device_io( PORT_LENGTH, BASE+3 );
	while (in8(ctrl_handle) & 0x20); // wait for ADWAIT to go low, base+3 bit 5

	ctrl_handle = mmap_device_io( PORT_LENGTH, BASE );
	out8(ctrl_handle,0x80); // start the A/D conversion


	// wait for ADBUSY to go low, base+3 bit 7


	while(checkstatus()){};

	ctrl_handle = mmap_device_io( PORT_LENGTH, BASE );
	uint8_t LSB = in8(ctrl_handle);
	ctrl_handle = mmap_device_io( PORT_LENGTH, BASE+1 );
	uint8_t MSB = in8(ctrl_handle);
	uint16_t ADdata = MSB * 256 + LSB; // combine the 2 bytes into a 16-bit value

	float InputVoltage=0;
	InputVoltage = float(ADdata / 32768) * 5;

	std::cout << InputVoltage << std::endl;


	return EXIT_SUCCESS;
}
